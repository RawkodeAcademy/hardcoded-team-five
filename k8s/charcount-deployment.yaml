apiVersion: apps/v1
kind: Deployment
metadata:
  name: charcount
  namespace: team-five
  labels:
    app: charcount
    service: text-analysis
spec:
  replicas: 1
  selector:
    matchLabels:
      app: charcount
  template:
    metadata:
      labels:
        app: charcount
    spec:
      containers:
      - name: charcount
        image: golang:1.21-alpine
        ports:
        - containerPort: 8007
        command:
          - /bin/sh
          - -c
        args:
          - |
            set -e
            mkdir -p /tmp/charcount
            cd /tmp/charcount
            go mod init charcount
            go get github.com/gorilla/mux@v1.8.0
            cat > /tmp/charcount/main.go << 'EOFAPP'
            package main

            import (
              "encoding/json"
              "fmt"
              "log"
              "net/http"
              "os"
              "sync/atomic"
              "unicode/utf8"

              "github.com/gorilla/mux"
            )

            type OpRequest struct {
              Text string `json:"text,omitempty"`
              Deps struct {
                Normalized string `json:"normalized,omitempty"`
              } `json:"deps,omitempty"`
            }

            type OpResponse struct {
              Key      string `json:"key"`
              Value    int    `json:"value"`
              CacheHit bool   `json:"cache_hit"`
            }

            type HealthResponse struct {
              OK bool `json:"ok"`
            }

            var requestsTotal int64

            func countChars(text string) int {
              if text == "" {
                return 0
              }
              return utf8.RuneCountInString(text)
            }

            func handleOp(w http.ResponseWriter, r *http.Request) {
              atomic.AddInt64(&requestsTotal, 1)
              
              w.Header().Set("Content-Type", "application/json")
              
              if r.Method != http.MethodPost {
                http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
                return
              }
              
              var req OpRequest
              if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
                response := OpResponse{
                  Key:      "char_count",
                  Value:    0,
                  CacheHit: false,
                }
                json.NewEncoder(w).Encode(response)
                return
              }
              
              textToCount := req.Deps.Normalized
              if textToCount == "" {
                textToCount = req.Text
              }
              
              charCount := countChars(textToCount)
              
              response := OpResponse{
                Key:      "char_count",
                Value:    charCount,
                CacheHit: false,
              }
              
              json.NewEncoder(w).Encode(response)
            }

            func handleHealth(w http.ResponseWriter, r *http.Request) {
              w.Header().Set("Content-Type", "application/json")
              
              response := HealthResponse{OK: true}
              json.NewEncoder(w).Encode(response)
            }

            func handleMetrics(w http.ResponseWriter, r *http.Request) {
              w.Header().Set("Content-Type", "text/plain")
              fmt.Fprintf(w, "# HELP charcount_requests_total Total requests processed\\n")
              fmt.Fprintf(w, "# TYPE charcount_requests_total counter\\n")
              fmt.Fprintf(w, "charcount_requests_total %d\\n", atomic.LoadInt64(&requestsTotal))
            }

            func main() {
              port := os.Getenv("PORT")
              if port == "" {
                port = "8007"
              }
              
              r := mux.NewRouter()
              
              r.HandleFunc("/op", handleOp).Methods("POST")
              r.HandleFunc("/healthz", handleHealth).Methods("GET")
              r.HandleFunc("/metrics", handleMetrics).Methods("GET")
              
              r.Use(func(next http.Handler) http.Handler {
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
                  w.Header().Set("Access-Control-Allow-Origin", "*")
                  w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS")
                  w.Header().Set("Access-Control-Allow-Headers", "Content-Type")
                  
                  if r.Method == "OPTIONS" {
                    w.WriteHeader(http.StatusOK)
                    return
                  }
                  
                  next.ServeHTTP(w, r)
                })
              })
              
              log.Printf("CharCount service starting on port %s", port)
              log.Printf("Endpoints: POST /op, GET /healthz, GET /metrics")
              
              if err := http.ListenAndServe(":"+port, r); err != nil {
                log.Fatal("Server failed to start:", err)
              }
            }
            EOFAPP
            exec go run main.go
        env:
        - name: PORT
          value: "8007"
        livenessProbe:
          httpGet:
            path: /healthz
            port: 8007
          initialDelaySeconds: 60
          periodSeconds: 30
          timeoutSeconds: 5
          failureThreshold: 3
        readinessProbe:
          httpGet:
            path: /healthz
            port: 8007
          initialDelaySeconds: 45
          periodSeconds: 10
          timeoutSeconds: 5
          failureThreshold: 3
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
---
apiVersion: v1
kind: Service
metadata:
  name: charcount-service
  namespace: team-five
  labels:
    app: charcount
spec:
  selector:
    app: charcount
  ports:
  - protocol: TCP
    port: 8007
    targetPort: 8007
  type: ClusterIP